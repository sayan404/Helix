import { NextRequest, NextResponse } from 'next/server';
import archiver from 'archiver';
import { ArchitectureBlueprint, CodeTemplate } from '@/lib/types';
import { Readable } from 'stream';

export async function POST(request: NextRequest) {
  try {
    const { architecture, codeTemplates } = await request.json() as {
      architecture: ArchitectureBlueprint;
      codeTemplates: CodeTemplate[];
    };

    if (!architecture) {
      return NextResponse.json(
        { error: 'Architecture blueprint required' },
        { status: 400 }
      );
    }

    // Create docker-compose.yml
    const dockerCompose = generateDockerCompose(architecture);
    
    // Create a README
    const readme = generateReadme(architecture);

    // Create the export package
    const exportData = {
      architecture,
      dockerCompose,
      readme,
      codeTemplates: codeTemplates || [],
    };

    return NextResponse.json(exportData);
  } catch (error) {
    console.error('Error in export API:', error);
    return NextResponse.json(
      { error: 'Failed to export project' },
      { status: 500 }
    );
  }
}

function generateDockerCompose(architecture: ArchitectureBlueprint): string {
  const services = architecture.services.map(service => {
    const serviceName = service.name.toLowerCase().replace(/\s+/g, '-');
    
    if (service.type === 'database') {
      return `  ${serviceName}:
    image: postgres:15-alpine
    environment:
      POSTGRES_PASSWORD: password
      POSTGRES_DB: ${serviceName}
    ports:
      - "5432"
    volumes:
      - ${serviceName}-data:/var/lib/postgresql/data`;
    } else if (service.type === 'cache') {
      return `  ${serviceName}:
    image: redis:7-alpine
    ports:
      - "6379"`;
    } else if (service.type === 'queue') {
      return `  ${serviceName}:
    image: rabbitmq:3-management-alpine
    ports:
      - "5672"
      - "15672"`;
    } else if (service.type === 'service') {
      return `  ${serviceName}:
    build: ./services/${serviceName}
    ports:
      - "3000"
    environment:
      - NODE_ENV=production`;
    }
    return '';
  }).filter(Boolean);

  const volumes = architecture.services
    .filter(s => s.type === 'database')
    .map(s => `  ${s.name.toLowerCase().replace(/\s+/g, '-')}-data:`)
    .join('\n');

  return `version: '3.8'

services:
${services.join('\n\n')}

${volumes ? `volumes:\n${volumes}` : ''}
`;
}

function generateReadme(architecture: ArchitectureBlueprint): string {
  return `# ${architecture.prompt}

## Architecture Overview

${architecture.summary}

## Components

${architecture.services.map(s => `- **${s.name}** (${s.type}): ${s.description || s.technology || ''}`).join('\n')}

## Architecture Patterns

${architecture.patterns.map(p => `- ${p}`).join('\n')}

## Scaling Model

${architecture.scaling_model}

## Cost Estimation

**Monthly Cost**: $${architecture.estimated_cost?.monthly_cost || 'N/A'}

### Breakdown:
- Compute: $${architecture.estimated_cost?.breakdown.compute || 0}
- Storage: $${architecture.estimated_cost?.breakdown.storage || 0}
- Network: $${architecture.estimated_cost?.breakdown.network || 0}
- Additional: $${architecture.estimated_cost?.breakdown.additional || 0}

## Getting Started

1. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

2. Start services with Docker Compose:
   \`\`\`bash
   docker-compose up -d
   \`\`\`

3. Access services:
   - Check docker-compose.yml for port mappings

## Generated by Helix

This architecture was generated by Helix - AI-Powered System Design Autopilot
`;
}

